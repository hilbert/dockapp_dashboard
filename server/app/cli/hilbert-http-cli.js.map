{"version":3,"sources":["cli/hilbert-http-cli.js"],"names":["http","require","https","yargs","callAPI","server","endpoint","httpMethod","data","Promise","resolve","reject","params","hostname","host","port","method","path","jsonData","JSON","stringify","headers","Buffer","byteLength","lib","startsWith","req","request","res","statusCode","Error","body","on","push","chunk","setEncoding","parse","join","err","write","end","listCommand","then","response","stations","station","console","log","id","startCommand","ids","startAllCommand","map","each","stopCommand","stopAllCommand","argv","options","h","alias","default","describe","type","p","command","demandCommand","strict","help","wrap","_","catch","error"],"mappings":"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","file":"cli/hilbert-http-cli.js","sourcesContent":["/**\n * Hilbert CLI http client\n *\n * A CLI program that connects to the Hilbert UI server via http and does things\n *\n */\nconst http = require('http');\nconst https = require('https');\nconst yargs = require('yargs');\n\n/**\n * Makes an API call and returns the response\n *\n * @param server Server address\n *  An object with host and port attributes\n * @param endpoint\n *  The API endpoint to call\n * @param httpMethod\n *  HTTP Method to use for the call (GET, POST, etc.)\n * @param data\n *  Data to send as part of the request\n */\nfunction callAPI(server, endpoint, httpMethod = 'GET', data = null) {\n  return new Promise((resolve, reject) => {\n    const params = {\n      hostname: server.host,\n      port: server.port,\n      method: httpMethod,\n      path: endpoint,\n    };\n\n    let jsonData = null;\n    if (data !== null) {\n      jsonData = JSON.stringify(data);\n      params.headers = {\n        'Content-Type': 'application/json',\n        'Content-Length': Buffer.byteLength(jsonData),\n      };\n    }\n\n    const lib = server.host.startsWith('https') ? https : http;\n    const req = lib.request(params,\n      (res) => {\n        if (res.statusCode < 200 || res.statusCode > 299) {\n          reject(new Error(`Failed to call remote API, status code: ${res.statusCode}`));\n        } else {\n          const body = [];\n          res.on('data', chunk => body.push(chunk));\n          res.on('end', () => {\n            res.setEncoding('utf8');\n            resolve(JSON.parse(body.join('')));\n          });\n        }\n      });\n\n    req.on('error', err => reject(err));\n\n    if (jsonData !== null) {\n      req.write(jsonData);\n    }\n    req.end();\n  });\n}\n\n/**\n * Prints a list of stations on the console\n *\n * @param server Server address\n *  An object with host and port attributes\n *\n * @return Promise\n */\nfunction listCommand(server) {\n  return callAPI(server, '/api/stations')\n    .then((response) => {\n      for (const station of response.stations) {\n        console.log(station.id);\n      }\n    });\n}\n\nfunction startCommand(server, stations) {\n  console.log(`Starting stations ${stations.join(', ')}`);\n  return callAPI(server, '/api/stations/start', 'POST', {\n    ids: stations,\n  });\n}\n\nfunction startAllCommand(server) {\n  console.log('Starting all stations');\n  return callAPI(server, '/api/stations')\n    .then(response => callAPI(server, '/api/stations/start', 'POST', {\n      ids: response.stations.map((each) => each.id),\n    })\n  );\n}\n\nfunction stopCommand(server, stations) {\n  console.log(`Stopping stations ${stations.join(', ')}`);\n  return callAPI(server, '/api/stations/stop', 'POST', {\n    ids: stations,\n  });\n}\n\nfunction stopAllCommand(server) {\n  console.log('Stopping all stations');\n  return callAPI(server, '/api/stations')\n    .then(response => callAPI(server, '/api/stations/stop', 'POST', {\n      ids: response.stations.map((each) => each.id),\n    })\n  );\n}\n\nconst argv = yargs\n  .options({\n    h: {\n      alias: 'host',\n      default: 'localhost',\n      describe: 'Hilbert UI server hostname',\n      type: 'string',\n    },\n    p: {\n      alias: 'port',\n      default: '8080',\n      describe: 'Hilbert UI server port',\n      type: 'number',\n    },\n  })\n  .command('list', 'List stations')\n  .command('start <stations..>', 'Start stations')\n  .command('stop <stations..>', 'Stop stations')\n  .command('startall', 'Start all stations')\n  .command('stopall', 'Stop all stations')\n  .demandCommand(1, 1, 'You must indicate a command to execute')\n  .strict()\n  .help()\n  .wrap(72)\n  .argv;\n\nconst server = {\n  host: argv.host,\n  port: argv.port,\n};\n\nlet command;\nswitch (argv._[0]) {\n  case 'list':\n    command = () => listCommand(server);\n    break;\n  case 'start':\n    command = () => startCommand(server, argv.stations);\n    break;\n  case 'stop':\n    command = () => stopCommand(server, argv.stations);\n    break;\n  case 'startall':\n    command = () => startAllCommand(server);\n    break;\n  case 'stopall':\n    command = () => stopAllCommand(server);\n    break;\n  default:\n    break;\n}\n\ncommand().catch(err => console.error(err));\n\n// Interface\n// listStations\n//   - as list of IDs\n//   - as table (id, name, app)\n// startStations (<list of stations>)\n//   - if all, confirm\n//   - -y overrides confirmation\n//   - --wait // waits until done (might not be possible *1)\n// stopStations (<list of stations>)\n//   - if all, confirm\n//   - -y overrides confirmation\n//   - --wait // waits until done (might not be possible *1)\n// availableApps <station>\n//   - prints list of applications for station\n// changeApp <appID> <stations>\n//   - Changes the app of stations to the indicated one\n//   - --wait // waits until done (might not be possible *1)\n//\n// *1 - To wait it's necessary to poll the state of the stations but:\n//      a - I would have to determine which stations CAN be started/stopped\n//      b - They might never reach the desired state for reasons beyond my control\n//\n// I still need:\n// - Richer responses on the back end (when it's not possible to start/stop/change a station)\n"],"sourceRoot":"/source/"}