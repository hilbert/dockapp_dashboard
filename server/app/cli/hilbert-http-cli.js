// Compiled by Babel
// ** DO NOT EDIT THIS FILE DIRECTLY **
//
'use strict';

/**
 * Hilbert CLI http client
 *
 * A CLI program that connects to the Hilbert UI server via http and does things
 *
 */
var http = require('http');
var https = require('https');
var yargs = require('yargs');

/**
 * Makes an API call and returns the response
 *
 * @param server Server address
 *  An object with host and port attributes
 * @param endpoint
 *  The API endpoint to call
 * @param httpMethod
 *  HTTP Method to use for the call (GET, POST, etc.)
 * @param data
 *  Data to send as part of the request
 */
function callAPI(server, endpoint) {
  var httpMethod = arguments.length <= 2 || arguments[2] === undefined ? 'GET' : arguments[2];
  var data = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

  return new Promise(function (resolve, reject) {
    var params = {
      hostname: server.host,
      port: server.port,
      method: httpMethod,
      path: endpoint
    };

    var jsonData = null;
    if (data !== null) {
      jsonData = JSON.stringify(data);
      params.headers = {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(jsonData)
      };
    }

    var lib = server.host.startsWith('https') ? https : http;
    var req = lib.request(params, function (res) {
      if (res.statusCode < 200 || res.statusCode > 299) {
        reject(new Error('Failed to call remote API, status code: ' + res.statusCode));
      } else {
        (function () {
          var body = [];
          res.on('data', function (chunk) {
            return body.push(chunk);
          });
          res.on('end', function () {
            res.setEncoding('utf8');
            resolve(JSON.parse(body.join('')));
          });
        })();
      }
    });

    req.on('error', function (err) {
      return reject(err);
    });

    if (jsonData !== null) {
      req.write(jsonData);
    }
    req.end();
  });
}

/**
 * Prints a list of stations on the console
 *
 * @param server Server address
 *  An object with host and port attributes
 *
 * @return Promise
 */
function listCommand(server) {
  return callAPI(server, '/api/stations').then(function (response) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = response.stations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var station = _step.value;

        console.log(station.id);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
}

function startCommand(server, stations) {
  console.log('Starting stations ' + stations.join(', '));
  return callAPI(server, '/api/stations/start', 'POST', {
    ids: stations
  });
}

function startAllCommand(server) {
  console.log('Starting all stations');
  return callAPI(server, '/api/stations').then(function (response) {
    return callAPI(server, '/api/stations/start', 'POST', {
      ids: response.stations.map(function (each) {
        return each.id;
      })
    });
  });
}

function stopCommand(server, stations) {
  console.log('Stopping stations ' + stations.join(', '));
  return callAPI(server, '/api/stations/stop', 'POST', {
    ids: stations
  });
}

function stopAllCommand(server) {
  console.log('Stopping all stations');
  return callAPI(server, '/api/stations').then(function (response) {
    return callAPI(server, '/api/stations/stop', 'POST', {
      ids: response.stations.map(function (each) {
        return each.id;
      })
    });
  });
}

var argv = yargs.options({
  h: {
    alias: 'host',
    default: 'localhost',
    describe: 'Hilbert UI server hostname',
    type: 'string'
  },
  p: {
    alias: 'port',
    default: '8080',
    describe: 'Hilbert UI server port',
    type: 'number'
  }
}).command('list', 'List stations').command('start <stations..>', 'Start stations').command('stop <stations..>', 'Stop stations').command('startall', 'Start all stations').command('stopall', 'Stop all stations').demandCommand(1, 1, 'You must indicate a command to execute').strict().help().wrap(72).argv;

var server = {
  host: argv.host,
  port: argv.port
};

var command = void 0;
switch (argv._[0]) {
  case 'list':
    command = function command() {
      return listCommand(server);
    };
    break;
  case 'start':
    command = function command() {
      return startCommand(server, argv.stations);
    };
    break;
  case 'stop':
    command = function command() {
      return stopCommand(server, argv.stations);
    };
    break;
  case 'startall':
    command = function command() {
      return startAllCommand(server);
    };
    break;
  case 'stopall':
    command = function command() {
      return stopAllCommand(server);
    };
    break;
  default:
    break;
}

command().catch(function (err) {
  return console.error(err);
});

// Interface
// listStations
//   - as list of IDs
//   - as table (id, name, app)
// startStations (<list of stations>)
//   - if all, confirm
//   - -y overrides confirmation
//   - --wait // waits until done (might not be possible *1)
// stopStations (<list of stations>)
//   - if all, confirm
//   - -y overrides confirmation
//   - --wait // waits until done (might not be possible *1)
// availableApps <station>
//   - prints list of applications for station
// changeApp <appID> <stations>
//   - Changes the app of stations to the indicated one
//   - --wait // waits until done (might not be possible *1)
//
// *1 - To wait it's necessary to poll the state of the stations but:
//      a - I would have to determine which stations CAN be started/stopped
//      b - They might never reach the desired state for reasons beyond my control
//
// I still need:
// - Richer responses on the back end (when it's not possible to start/stop/change a station)
//# sourceMappingURL=hilbert-http-cli.js.map
