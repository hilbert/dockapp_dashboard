{"version":3,"sources":["lib/long-poll-handler.js"],"names":["Promise","require","EventEmitter","LongPollHandler","timeoutSecs","updateID","events","updateEventEmitter","setMaxListeners","req","res","resolve","reject","Number","query","lastUpdateID","pollTimeout","updateHandler","clearTimeout","once","setTimeout","removeListener","emit","Error"],"mappings":";;;;;;;;;;AAAA,IAAMA,UAAUC,QAAQ,UAAR,CAAhB;AACA,IAAMC,eAAeD,QAAQ,QAAR,EAAkBC,YAAvC;;AAEA;;;;IAGqBC,e;;AAEnB;;;;AAIA,6BAA8B;AAAA,QAAlBC,WAAkB,yDAAJ,EAAI;;AAAA;;AAC5B,SAAKA,WAAL,GAAmBA,WAAnB;AACA,SAAKC,QAAL,GAAgB,CAAhB;;AAEA,SAAKC,MAAL,GAAc,IAAIJ,YAAJ,EAAd;;AAEA,SAAKK,kBAAL,GAA0B,IAAIL,YAAJ,EAA1B;AACA,SAAKK,kBAAL,CAAwBC,eAAxB,CAAwC,GAAxC;AACD;;AAED;;;;;;;;;;;;;;;;;;;;kCAgBcC,G,EAAKC,G,EAAK;AAAA;;AACtB,aAAO,IAAIV,OAAJ,CAAY,UAACW,OAAD,EAAUC,MAAV,EAAqB;AACtC;AACA,YAAIC,OAAOJ,IAAIK,KAAJ,CAAUC,YAAjB,MAAmC,MAAKV,QAA5C,EAAsD;AACpDM,kBAAQ,MAAKN,QAAb;AACD,SAFD,MAEO;AAAA;AACL;;AAEA,gBAAIW,cAAc,IAAlB;AACA;AACA,gBAAMC,gBAAgB,SAAhBA,aAAgB,GAAM;AAC1BC,2BAAaF,WAAb;AACAL,sBAAQ,MAAKN,QAAb;AACD,aAHD;AAIA,kBAAKE,kBAAL,CAAwBY,IAAxB,CAA6B,QAA7B,EAAuCF,aAAvC;;AAEA;AACAD,0BAAcI,WAAW,YAAM;AAC7B,oBAAKb,kBAAL,CAAwBc,cAAxB,CAAuC,QAAvC,EAAiDJ,aAAjD;AACA,oBAAKX,MAAL,CAAYgB,IAAZ,CAAiB,SAAjB;AACAV,qBAAOW,MAAM,8BAAN,CAAP;AACD,aAJa,EAIX,MAAKnB,WAAL,GAAmB,IAJR,CAAd;;AAMA,kBAAKE,MAAL,CAAYgB,IAAZ,CAAiB,MAAjB;AAlBK;AAmBN;AACF,OAxBM,CAAP;AAyBD;;AAED;;;;;;;;mCAKe;AACb,WAAKjB,QAAL,IAAiB,CAAjB;AACA,WAAKE,kBAAL,CAAwBe,IAAxB,CAA6B,QAA7B;AACD;;;;;;kBApEkBnB,e","file":"lib/long-poll-handler.js","sourcesContent":["const Promise = require('bluebird');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Manages Long Polling for a single HTTP API endpoint\n */\nexport default class LongPollHandler {\n\n  /**\n   * Constructor\n   * @param timeoutSecs Long poll timeout (in seconds)\n   */\n  constructor(timeoutSecs = 15) {\n    this.timeoutSecs = timeoutSecs;\n    this.updateID = 1;\n\n    this.events = new EventEmitter();\n\n    this.updateEventEmitter = new EventEmitter();\n    this.updateEventEmitter.setMaxListeners(100);\n  }\n\n  /**\n   * Handles an http request using long polling\n   *\n   * Call this method upon receiving an http request. It returns a\n   * promise that signals when the client can send the response.\n   *\n   * If the client is synced it the promise will resolve immediately.\n   * If the client is out of sync the promise will resolve as soon as\n   * the handler is signaled that there are updates, or will reject if\n   * there is a time out (in which case the client can send an empty\n   * response)\n   **\n   * @param req HTTP Request (express)\n   * @param res HTTP Response (express)\n   * @return {Promise}\n   */\n  handleRequest(req, res) {\n    return new Promise((resolve, reject) => {\n      // If the client is out of sync we can respond right away\n      if (Number(req.query.lastUpdateID) !== this.updateID) {\n        resolve(this.updateID);\n      } else {\n        // If the client is synced...\n\n        let pollTimeout = null;\n        // Respond when an update arrives (and clear the timeout)\n        const updateHandler = () => {\n          clearTimeout(pollTimeout);\n          resolve(this.updateID);\n        };\n        this.updateEventEmitter.once('update', updateHandler);\n\n        // Time out if no updates arrive (and remove the update handler)\n        pollTimeout = setTimeout(() => {\n          this.updateEventEmitter.removeListener('update', updateHandler);\n          this.events.emit('timeout');\n          reject(Error('Time out waiting for updates'));\n        }, this.timeoutSecs * 1000);\n\n        this.events.emit('wait');\n      }\n    });\n  }\n\n  /**\n   * Signal the handler that the data associated with this endpoint updated\n   *\n   * The handler emits an internal event to wake all waiting requests.\n   */\n  signalUpdate() {\n    this.updateID += 1;\n    this.updateEventEmitter.emit('update');\n  }\n}\n"],"sourceRoot":"/source/"}